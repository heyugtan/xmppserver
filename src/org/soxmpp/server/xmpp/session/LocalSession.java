/*
 * Copyright (C) 2010 Moduad Co., Ltd.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
package org.soxmpp.server.xmpp.session;

import java.net.UnknownHostException;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.soxmpp.server.xmpp.UnauthenticatedException;
import org.soxmpp.server.xmpp.net.Connection;
import org.xmpp.packet.JID;
import org.xmpp.packet.Packet;

/**
 * This is an abstract class for a session between the server and a client.
 * 
 * @author Sehwan Noh (devnoh@gmail.com)
 */
public abstract class LocalSession implements Session {

	private static final Logger Log = LoggerFactory
			.getLogger(LocalSession.class);

	/**
	 * The utf-8 charset for decoding and encoding Jabber packet streams.
	 */
	protected static String CHARSET = "UTF-8";

	/**
	 * The Address this session is authenticated as.
	 */
	private JID address;

	/**
	 * The stream id for this session (random and unique).
	 */
	private String streamID;

	/**
	 * The current session status.
	 */
	protected int status = STATUS_CONNECTED;

	/**
	 * The connection that this session represents.
	 */
	protected final Connection conn;

	private String serverName;

	private long startDate = System.currentTimeMillis();

	private long lastActiveDate;
	private long clientPacketCount = 0;
	private long serverPacketCount = 0;

	/**
	 * Session temporary data. All data stored in this <code>Map</code> disapear
	 * when session finishes.
	 */
	private final Map<String, Object> sessionData = new HashMap<String, Object>();

	/**
	 * Creates a session with an underlying connection and permission
	 * protection.
	 * 
	 * @param serverName
	 *            domain of the XMPP server where the new session belongs.
	 * @param connection
	 *            The connection we are proxying.
	 * @param streamID
	 *            unique identifier for this session.
	 */
	public LocalSession(String serverName, Connection connection,
			String streamID) {
		if (connection == null) {
			throw new IllegalArgumentException("connection must not be null");
		}
		conn = connection;
		this.streamID = streamID;
		this.serverName = serverName;
		this.address = new JID(null, serverName, this.streamID, true);
	}

	/**
	 * Obtain the address of the user. The address is used by services like the
	 * core server packet router to determine if a packet should be sent to the
	 * handler. Handlers that are working on behalf of the server should use the
	 * generic server hostname address (e.g. server.com).
	 * 
	 * @return the address of the packet handler.
	 */
	public JID getAddress() {
		return address;
	}

	/**
	 * Sets the new address of this session. The address is used by services
	 * like the core server packet router to determine if a packet should be
	 * sent to the handler. Handlers that are working on behalf of the server
	 * should use the generic server hostname address (e.g. server.com).
	 * 
	 * @param address
	 *            the new address of this session.
	 */
	public void setAddress(JID address) {
		this.address = address;
	}

	/**
	 * Returns the connection associated with this Session.
	 * 
	 * @return The connection for this session
	 */
	public Connection getConnection() {
		return conn;
	}

	/**
	 * Obtain the current status of this session.
	 * 
	 * @return The status code for this session
	 */
	public int getStatus() {
		return status;
	}

	/**
	 * Set the new status of this session. Setting a status may trigger certain
	 * events to occur (setting a closed status will close this session).
	 * 
	 * @param status
	 *            The new status code for this session
	 */
	public void setStatus(int status) {
		this.status = status;
	}

	/**
	 * Obtain the stream ID associated with this sesison. Stream ID's are
	 * generated by the server and should be unique and random.
	 * 
	 * @return This session's assigned stream ID
	 */
	public String getStreamID() {
		return streamID;
	}

	/**
	 * Obtain the name of the server this session belongs to.
	 * 
	 * @return the server name.
	 */
	public String getServerName() {
		return serverName;
	}

	/**
	 * Obtain the date the session was created.
	 * 
	 * @return the session's creation date.
	 */
	public Date getCreationDate() {
		return new Date(startDate);
	}

	/**
	 * Obtain the time the session last had activity.
	 * 
	 * @return The last time the session received activity.
	 */
	public Date getLastActiveDate() {
		return new Date(lastActiveDate);
	}

	/**
	 * Increments the number of packets sent from the client to the server.
	 */
	public void incrementClientPacketCount() {
		clientPacketCount++;
		lastActiveDate = System.currentTimeMillis();
	}

	/**
	 * Increments the number of packets sent from the server to the client.
	 */
	public void incrementServerPacketCount() {
		serverPacketCount++;
		lastActiveDate = System.currentTimeMillis();
	}

	/**
	 * Obtain the number of packets sent from the client to the server.
	 * 
	 * @return The number of packets sent from the client to the server.
	 */
	public long getNumClientPackets() {
		return clientPacketCount;
	}

	/**
	 * Obtain the number of packets sent from the server to the client.
	 * 
	 * @return The number of packets sent from the server to the client.
	 */
	public long getNumServerPackets() {
		return serverPacketCount;
	}

	/**
	 * Saves given session data. Data are saved to temporary storage only and
	 * are accessible during this session life only and only from this session
	 * instance.
	 * 
	 * @param key
	 *            a <code>String</code> value of stored data key ID.
	 * @param value
	 *            a <code>Object</code> value of data stored in session.
	 * @see #getSessionData(String)
	 */
	public void setSessionData(String key, Object value) {
		synchronized (sessionData) {
			sessionData.put(key, value);
		}
	}

	/**
	 * Retrieves session data. This method gives access to temporary session
	 * data only. You can retrieve earlier saved data giving key ID to receive
	 * needed value. Please see {@link #setSessionData(String, Object)}
	 * description for more details.
	 * 
	 * @param key
	 *            a <code>String</code> value of stored data ID.
	 * @return a <code>Object</code> value of data for given key.
	 * @see #setSessionData(String, Object)
	 */
	public Object getSessionData(String key) {
		synchronized (sessionData) {
			return sessionData.get(key);
		}
	}

	/**
	 * Removes session data. Please see {@link #setSessionData(String, Object)}
	 * description for more details.
	 * 
	 * @param key
	 *            a <code>String</code> value of stored data ID.
	 * @see #setSessionData(String, Object)
	 */
	public void removeSessionData(String key) {
		synchronized (sessionData) {
			sessionData.remove(key);
		}
	}

	/**
	 * Process the packet.
	 * 
	 * @param packet
	 *            the packet to process
	 */
	public void process(Packet packet) {
		try {
			deliver(packet);
		} catch (Exception e) {
			Log.error("Internal server error", e);
		}
	}

	/**
	 * Delivers the packet to the associated connection.
	 * 
	 * @param packet
	 *            the packet to deliver
	 * @throws UnauthenticatedException
	 */
	public void deliver(Packet packet) throws UnauthenticatedException {
		if (this.conn != null && !this.conn.isClosed()) {
			this.conn.deliver(packet);
		}
	}

	/**
	 * Delivers raw text to the associated connection.
	 * 
	 * @param text
	 *            the XML stanza string to deliver
	 */
	public void deliverRawText(String text) {
		if (this.conn != null) {
			this.conn.deliverRawText(text);
		}
	}

	/**
	 * Close the session including associated socket connection.
	 */
	public void close() {
		if (this.conn != null) {
			this.conn.close();
		}
	}

	/**
	 * Returns true if the connection is closed.
	 * 
	 * @return true if the connection is closed, flase otherwise.
	 */
	public boolean isClosed() {
		return this.conn.isClosed();
	}

	public boolean isSecure() {
		return this.conn.isSecure();
	}

	public boolean validate() {
		return this.conn.validate();
	}

	/**
	 * Returns the IP address.
	 * 
	 * @return the IP address
	 */
	public String getHostAddress() throws UnknownHostException {
		return this.conn.getHostAddress();
	}

	/**
	 * Gets the host name for the IP address.
	 * 
	 * @return the host name for this IP address
	 */
	public String getHostName() throws UnknownHostException {
		return this.conn.getHostName();
	}

	/**
	 * Returns a text with the available stream features.
	 */
	public abstract String getAvailableStreamFeatures();

	@Override
	public String toString() {
		return super.toString() + " status: " + status + " address: " + address
				+ " id: " + streamID;
	}

}
